# 계단 오르기

## DP

---
### 풀이방법
계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 
즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.

- 점화식 문제
- 점화식을 찾을 때 3번 규칙 (마지막 도착 계단은 반드시 밟아야 한다) 따라야함
- 점화식을 계단을 올라가는 앞에서 생각하는 방식보다는 도착지부터 생각하는 방식
- 1.n-1번째 계단으로 오는 경우에는
    `dp[n] = dp[n-3] + stairs[n-1] + stairs[n]` - n-3까지의 계단 점수 최댓값과 n-1, n 계단의 합.
- 2.n-2번째 계단으로 오는 경우에는
    `dp[n] = dp[n-2] + stairs[n]`   -  n-2까지의 계단 점수 최댓값과 n 계단의 합
- 이 중에서 더 큰 수가 dp[n]
- 3번째 계단부터 2계단을 연속으로 걸었을 때와, 1계단을 건너뛴 것을 비교해서 최댓값을 계속 갱신

- n에 계단개수를 입력받고, s에는 각 계단의 점수를 리스트로 입력받음
- 계단이 2개 이하라면, 1개일 땐 그 계단 점수가 최대이고, 2개일 땐 2개 계단의 점수를 합한 게 최대
- dp리스트는 각 인덱스에 최대 점수가 들어감


---

### 코드

```python
n=int(input()) # 계단 개수
s=[int(input()) for _ in range(n)] # 계단 리스트
dp=[0]*(n) # dp 리스트
if len(s)<=2: # 계단이 2개 이하일땐 그냥 다 더해서 출력
    print(sum(s))
else: # 계단이 3개 이상일 때
    dp[0]=s[0] # 첫째 계단 수동 계산
    dp[1]=s[0]+s[1] # 둘째 계단까지 수동 계산
    for i in range(2,n): # 3번째 계단 부터 dp 점화식 이용해서 최대값 구하기
        dp[i]=max(dp[i-3]+s[i-1]+s[i], dp[i-2]+s[i])
    print(dp[-1])
```