# 계단오르기 - 2579

## 접근방법
- dp인것을 알고, 최소값을 어떻게 구할지 접근함
- 이전에 한 개의 계단을 올랐을 때와 두 개의 계단을 오른 경우중에 정하려고 반복문을 두 개 사용하려고 했는데, 원하는 값이 안나오고 띄어서 나옴
- 나중에 정답을 보고 알게됨. 하나이전의 조건을 생각하는게 아니라 두 개 이전의 조건부터 하나이전의 조건을 고려하는 방식으로 생각해야함

### 풀이코드

```py
# dp 는 해당 계단을 오르기까지 최대 점수
# 계단 하나를 오르는데까지 최대 점수는 dp[1]까지의 최대와, stairs배열[1]의 값을 더한 것
# 근데 증가량이 1, 또는 2이고, 이전에 1이었다면 2로 갈 수 없다.
# dp의 첫 자리에는 최대점수, dp 두번째 자리에 이전에 밟은 계단이 주어진다.
N = int(input())
# dp[1]과 [2]에 값을 무조건 할당하기때문에, 배열의 크기를 +2로 설정 아래 stairs도 같은 맥락이다.
dp = [0]*(N+2)
stairs = [0] + [int(input()) for _ in range(N)]+[0]

dp[1] = stairs[1]
dp[2] = dp[1]+stairs[2]
# 여기서 3을 시작점으로 해놓지 않는 경우, index에러가 난다.
for i in range(3,N+1):
    # 핵심 코드. 이전에 하나의 계단을 오른 경우, 그 전에는 두개의 계단을 올랐어야 한다.(두 개 전의 상황을 생각할것!)
    dp[i] = max((dp[i-3]+stairs[i-1]),dp[i-2]) + stairs[i]
print(dp[N])
```